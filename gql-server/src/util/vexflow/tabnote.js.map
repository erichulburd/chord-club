{"version":3,"sources":["../../../node_modules/vexflow/src/tabnote.js"],"names":["getUnusedStringGroups","num_lines","strings_used","stem_through","group","string","is_used","indexOf","push","length","getPartialStemLines","stem_y","unused_strings","stave","stem_direction","up_stem","down_stem","line_spacing","getSpacingBetweenLines","total_lines","getNumLines","stem_lines","forEach","strings","containsLastString","containsFirstString","line_ys","index","isTopBound","isBottomBound","y","getYForLine","sort","a","b","TabNote","StemmableNote","CATEGORY","constructor","tab_struct","draw_stem","setAttribute","ghost","positions","Vex","Merge","render_options","glyph_font_scale","Flow","DEFAULT_TABLATURE_FONT_SCALE","draw_dots","draw_stem_through_stave","y_shift","scale","font","glyph","getGlyphProps","duration","noteType","RuntimeError","JSON","stringify","buildStem","setStemDirection","Stem","UP","updateWidth","reset","setStave","getCategory","setGhost","hasStem","getStemExtension","getGlyph","stem_extension_override","getStemDirection","tabnote_stem_up_extension","tabnote_stem_down_extension","addDot","dot","Dot","dots","addModifier","glyphs","width","i","fret","tabToGlyph","Math","max","getWidth","context","ctx","text","toUpperCase","save","setRawFont","measureText","restore","ys","map","str","line","setYs","stem","setYBounds","getStemY","getPositions","addToModifierContext","mc","setModifierContext","modifiers","modifierContext","preFormatted","getTieRightX","tieStartX","getAbsoluteX","note_glyph_width","getTieLeftX","tieEndX","getModifierStartXY","position","RERR","x","Modifier","Position","LEFT","RIGHT","BELOW","ABOVE","getLineForRest","preFormat","setPreFormatted","getStemX","getCenterGlyphX","stemUpLine","stemDownLine","stemStartLine","getStemExtents","getExtents","drawFlag","beam","shouldDrawFlag","flag","flag_x","flag_y","getHeight","flag_code","DOWN","code_flag_downstem","code_flag_upstem","Glyph","renderGlyph","category","drawModifiers","modifier","setContext","drawWithStyle","drawStemThrough","stem_x","getStave","setLineWidth","WIDTH","bounds","beginPath","moveTo","lineTo","stroke","closePath","drawPositions","tab_x","clearRect","code","toString","fillText","draw","checkContext","setRendered","render_stem","setNoteHeadXBounds","openGroup","pointerBBox","closeGroup"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// The file implements notes for Tablature notation. This consists of one or\n// more fret positions, and can either be drawn with or without stems.\n//\n// See `tests/tabnote_tests.js` for usage examples\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { Stem } from './stem';\nimport { StemmableNote } from './stemmablenote';\nimport { Dot } from './dot';\nimport { Glyph } from './glyph';\n\n// Gets the unused strings grouped together if consecutive.\n//\n// Parameters:\n// * num_lines - The number of lines\n// * strings_used - An array of numbers representing which strings have fret positions\nfunction getUnusedStringGroups(num_lines, strings_used) {\n  const stem_through = [];\n  let group = [];\n  for (let string = 1; string <= num_lines; string++) {\n    const is_used = strings_used.indexOf(string) > -1;\n\n    if (!is_used) {\n      group.push(string);\n    } else {\n      stem_through.push(group);\n      group = [];\n    }\n  }\n  if (group.length > 0) stem_through.push(group);\n\n  return stem_through;\n}\n\n// Gets groups of points that outline the partial stem lines\n// between fret positions\n//\n// Parameters:\n// * stem_Y - The `y` coordinate the stem is located on\n// * unused_strings - An array of groups of unused strings\n// * stave - The stave to use for reference\n// * stem_direction - The direction of the stem\nfunction getPartialStemLines(stem_y, unused_strings, stave, stem_direction) {\n  const up_stem = stem_direction !== 1;\n  const down_stem = stem_direction !== -1;\n\n  const line_spacing = stave.getSpacingBetweenLines();\n  const total_lines = stave.getNumLines();\n\n  const stem_lines = [];\n\n  unused_strings.forEach(strings => {\n    const containsLastString = strings.indexOf(total_lines) > -1;\n    const containsFirstString =  strings.indexOf(1) > -1;\n\n    if ((up_stem && containsFirstString) ||\n       (down_stem && containsLastString)) {\n      return;\n    }\n\n    // If there's only one string in the group, push a duplicate value.\n    // We do this because we need 2 strings to convert into upper/lower y\n    // values.\n    if (strings.length === 1) {\n      strings.push(strings[0]);\n    }\n\n    const line_ys = [];\n    // Iterate through each group string and store it's y position\n    strings.forEach((string, index, strings) => {\n      const isTopBound = string === 1;\n      const isBottomBound = string === total_lines;\n\n      // Get the y value for the appropriate staff line,\n      // we adjust for a 0 index array, since string numbers are index 1\n      let y = stave.getYForLine(string - 1);\n\n      // Unless the string is the first or last, add padding to each side\n      // of the line\n      if (index === 0 && !isTopBound) {\n        y -= line_spacing / 2 - 1;\n      } else if (index === strings.length - 1 && !isBottomBound) {\n        y += line_spacing / 2 - 1;\n      }\n\n      // Store the y value\n      line_ys.push(y);\n\n      // Store a subsequent y value connecting this group to the main\n      // stem above/below the stave if it's the top/bottom string\n      if (stem_direction === 1 && isTopBound) {\n        line_ys.push(stem_y - 2);\n      } else if (stem_direction === -1 && isBottomBound) {\n        line_ys.push(stem_y + 2);\n      }\n    });\n\n    // Add the sorted y values to the\n    stem_lines.push(line_ys.sort((a, b) => a - b));\n  });\n\n  return stem_lines;\n}\n\nexport class TabNote extends StemmableNote {\n  static get CATEGORY() { return 'tabnotes'; }\n\n  // Initialize the TabNote with a `tab_struct` full of properties\n  // and whether to `draw_stem` when rendering the note\n  constructor(tab_struct, draw_stem) {\n    super(tab_struct);\n    this.setAttribute('type', 'TabNote');\n\n    this.ghost = false; // Renders parenthesis around notes\n    // Note properties\n    //\n    // The fret positions in the note. An array of `{ str: X, fret: X }`\n    this.positions = tab_struct.positions;\n\n    // Render Options\n    Vex.Merge(this.render_options, {\n      // font size for note heads and rests\n      glyph_font_scale: Flow.DEFAULT_TABLATURE_FONT_SCALE,\n      // Flag to draw a stem\n      draw_stem,\n      // Flag to draw dot modifiers\n      draw_dots: draw_stem,\n      // Flag to extend the main stem through the stave and fret positions\n      draw_stem_through_stave: false,\n      // vertical shift from stave line\n      y_shift: 0,\n      // normal glyph scale\n      scale: 1.0,\n      // default tablature font\n      font: '10pt Arial',\n    });\n\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n\n    if (!this.glyph) {\n      throw new Vex.RuntimeError(\n        'BadArguments',\n        `Invalid note initialization data (No glyph found): ${JSON.stringify(tab_struct)}`\n      );\n    }\n\n    this.buildStem();\n\n    if (tab_struct.stem_direction) {\n      this.setStemDirection(tab_struct.stem_direction);\n    } else {\n      this.setStemDirection(Stem.UP);\n    }\n\n    // Renders parenthesis around notes\n    this.ghost = false;\n    this.updateWidth();\n  }\n\n  reset() {\n    if (this.stave) this.setStave(this.stave);\n  }\n\n  // The ModifierContext category\n  getCategory() { return TabNote.CATEGORY; }\n\n  // Set as ghost `TabNote`, surrounds the fret positions with parenthesis.\n  // Often used for indicating frets that are being bent to\n  setGhost(ghost) {\n    this.ghost = ghost;\n    this.updateWidth();\n    return this;\n  }\n\n  // Determine if the note has a stem\n  hasStem() { return this.render_options.draw_stem; }\n\n  // Get the default stem extension for the note\n  getStemExtension() {\n    const glyph = this.getGlyph();\n\n    if (this.stem_extension_override != null) {\n      return this.stem_extension_override;\n    }\n\n    if (glyph) {\n      return this.getStemDirection() === 1\n        ? glyph.tabnote_stem_up_extension\n        : glyph.tabnote_stem_down_extension;\n    }\n\n    return 0;\n  }\n\n  // Add a dot to the note\n  addDot() {\n    const dot = new Dot();\n    this.dots += 1;\n    return this.addModifier(dot, 0);\n  }\n\n  // Calculate and store the width of the note\n  updateWidth() {\n    this.glyphs = [];\n    this.width = 0;\n    for (let i = 0; i < this.positions.length; ++i) {\n      let fret = this.positions[i].fret;\n      if (this.ghost) fret = '(' + fret + ')';\n      const glyph = Flow.tabToGlyph(fret, this.render_options.scale);\n      this.glyphs.push(glyph);\n      this.width = Math.max(glyph.getWidth(), this.width);\n    }\n    // For some reason we associate a notehead glyph with a TabNote, and this\n    // glyph is used for certain width calculations. Of course, this is totally\n    // incorrect since a notehead is a poor approximation for the dimensions of\n    // a fret number which can have multiple digits. As a result, we must\n    // overwrite getWidth() to return the correct width\n    this.glyph.getWidth = () => this.width;\n  }\n\n  // Set the `stave` to the note\n  setStave(stave) {\n    super.setStave(stave);\n    this.context = stave.context;\n\n    // Calculate the fret number width based on font used\n    let i;\n    if (this.context) {\n      const ctx = this.context;\n      this.width = 0;\n      for (i = 0; i < this.glyphs.length; ++i) {\n        const glyph = this.glyphs[i];\n        const text = '' + glyph.text;\n        if (text.toUpperCase() !== 'X') {\n          ctx.save();\n          ctx.setRawFont(this.render_options.font);\n          glyph.width = ctx.measureText(text).width;\n          ctx.restore();\n          glyph.getWidth = () => glyph.width;\n        }\n        this.width = Math.max(glyph.getWidth(), this.width);\n      }\n      this.glyph.getWidth = () => this.width;\n    }\n\n    // we subtract 1 from `line` because getYForLine expects a 0-based index,\n    // while the position.str is a 1-based index\n    const ys = this.positions.map(({ str: line }) => stave.getYForLine(line - 1));\n\n    this.setYs(ys);\n\n    if (this.stem) {\n      this.stem.setYBounds(this.getStemY(), this.getStemY());\n    }\n\n    return this;\n  }\n\n  // Get the fret positions for the note\n  getPositions() { return this.positions; }\n\n  // Add self to the provided modifier context `mc`\n  addToModifierContext(mc) {\n    this.setModifierContext(mc);\n    for (let i = 0; i < this.modifiers.length; ++i) {\n      this.modifierContext.addModifier(this.modifiers[i]);\n    }\n    this.modifierContext.addModifier(this);\n    this.preFormatted = false;\n    return this;\n  }\n\n  // Get the `x` coordinate to the right of the note\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    const note_glyph_width = this.glyph.getWidth();\n    tieStartX += note_glyph_width / 2;\n    tieStartX += (-this.width / 2) + this.width + 2;\n\n    return tieStartX;\n  }\n\n  // Get the `x` coordinate to the left of the note\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    const note_glyph_width = this.glyph.getWidth();\n    tieEndX += note_glyph_width / 2;\n    tieEndX -= (this.width / 2) + 2;\n\n    return tieEndX;\n  }\n\n  // Get the default `x` and `y` coordinates for a modifier at a specific\n  // `position` at a fret position `index`\n  getModifierStartXY(position, index) {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-Values calculated for this note.');\n    }\n\n    let x = 0;\n    if (position === Modifier.Position.LEFT) {\n      x = -1 * 2;  // FIXME: modifier padding, move to font file\n    } else if (position === Modifier.Position.RIGHT) {\n      x = this.width + 2; // FIXME: modifier padding, move to font file\n    } else if (position === Modifier.Position.BELOW || position === Modifier.Position.ABOVE) {\n      const note_glyph_width = this.glyph.getWidth();\n      x = note_glyph_width / 2;\n    }\n\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index],\n    };\n  }\n\n  // Get the default line for rest\n  getLineForRest() { return this.positions[0].str; }\n\n  // Pre-render formatting\n  preFormat() {\n    if (this.preFormatted) return;\n    if (this.modifierContext) this.modifierContext.preFormat();\n    // width is already set during init()\n    this.setPreFormatted(true);\n  }\n\n  // Get the x position for the stem\n  getStemX() { return this.getCenterGlyphX(); }\n\n  // Get the y position for the stem\n  getStemY() {\n    const num_lines = this.stave.getNumLines();\n\n    // The decimal staff line amounts provide optimal spacing between the\n    // fret number and the stem\n    const stemUpLine = -0.5;\n    const stemDownLine = num_lines - 0.5;\n    const stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;\n\n    return this.stave.getYForLine(stemStartLine);\n  }\n\n  // Get the stem extents for the tabnote\n  getStemExtents() {\n    return this.stem.getExtents();\n  }\n\n  // Draw the fal onto the context\n  drawFlag() {\n    const {\n      beam, glyph, context, stem, stem_direction,\n      render_options: { draw_stem, glyph_font_scale },\n    } = this;\n\n    const shouldDrawFlag = beam == null && draw_stem;\n\n    // Now it's the flag's turn.\n    if (glyph.flag && shouldDrawFlag) {\n      const flag_x = this.getStemX() + 1;\n      const flag_y = this.getStemY() - stem.getHeight();\n\n      const flag_code = stem_direction === Stem.DOWN\n        ? glyph.code_flag_downstem // Down stems have flags on the left.\n        : glyph.code_flag_upstem;\n\n      // Draw the Flag\n      Glyph.renderGlyph(context, flag_x, flag_y, glyph_font_scale, flag_code, { category: 'flag.tabStem' });\n    }\n  }\n\n  // Render the modifiers onto the context\n  drawModifiers() {\n    // Draw the modifiers\n    this.modifiers.forEach((modifier) => {\n      // Only draw the dots if enabled\n      if (modifier.getCategory() === 'dots' && !this.render_options.draw_dots) return;\n\n      modifier.setContext(this.context);\n      modifier.drawWithStyle();\n    });\n  }\n\n  // Render the stem extension through the fret positions\n  drawStemThrough() {\n    const stem_x = this.getStemX();\n    const stem_y = this.getStemY();\n    const ctx = this.context;\n\n    const stem_through = this.render_options.draw_stem_through_stave;\n    const draw_stem = this.render_options.draw_stem;\n    if (draw_stem && stem_through) {\n      const total_lines = this.stave.getNumLines();\n      const strings_used = this.positions.map(position => position.str);\n\n      const unused_strings = getUnusedStringGroups(total_lines, strings_used);\n      const stem_lines = getPartialStemLines(\n        stem_y,\n        unused_strings,\n        this.getStave(),\n        this.getStemDirection()\n      );\n\n      ctx.save();\n      ctx.setLineWidth(Stem.WIDTH);\n      stem_lines.forEach(bounds => {\n        if (bounds.length === 0) return;\n\n        ctx.beginPath();\n        ctx.moveTo(stem_x, bounds[0]);\n        ctx.lineTo(stem_x, bounds[bounds.length - 1]);\n        ctx.stroke();\n        ctx.closePath();\n      });\n      ctx.restore();\n    }\n  }\n\n  // Render the fret positions onto the context\n  drawPositions() {\n    const ctx = this.context;\n    const x = this.getAbsoluteX();\n    const ys = this.ys;\n    for (let i = 0; i < this.positions.length; ++i) {\n      const y = ys[i] + this.render_options.y_shift;\n      const glyph = this.glyphs[i];\n\n      // Center the fret text beneath the notation note head\n      const note_glyph_width = this.glyph.getWidth();\n      const tab_x = x + (note_glyph_width / 2) - (glyph.getWidth() / 2);\n\n      // FIXME: Magic numbers.\n      ctx.clearRect(tab_x - 2, y - 3, glyph.getWidth() + 4, 6);\n\n      if (glyph.code) {\n        Glyph.renderGlyph(ctx, tab_x, y,\n          this.render_options.glyph_font_scale * this.render_options.scale,\n          glyph.code);\n      } else {\n        ctx.save();\n        ctx.setRawFont(this.render_options.font);\n        const text = glyph.text.toString();\n        ctx.fillText(text, tab_x, y + 5 * this.render_options.scale);\n        ctx.restore();\n      }\n    }\n  }\n\n  // The main rendering function for the entire note\n  draw() {\n    this.checkContext();\n\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', \"Can't draw note without Y values.\");\n    }\n\n    this.setRendered();\n    const render_stem = this.beam == null && this.render_options.draw_stem;\n\n    this.drawPositions();\n    this.drawStemThrough();\n\n    const stem_x = this.getStemX();\n\n    this.stem.setNoteHeadXBounds(stem_x, stem_x);\n\n    if (render_stem) {\n      this.context.openGroup('stem', null, { pointerBBox: true });\n      this.stem.setContext(this.context).draw();\n      this.context.closeGroup();\n    }\n\n    this.drawFlag();\n    this.drawModifiers();\n  }\n}\n"],"file":"tabnote.js"}