{"version":3,"sources":["../../../node_modules/vexflow/src/formatter.js"],"names":["L","args","Formatter","DEBUG","Vex","lookAhead","notes","restLine","i","compare","nextRestLine","length","note","isRest","shouldIgnoreTicks","getLineForRest","top","Math","max","bot","min","MidLine","createContexts","voices","ContextType","addToContext","RERR","totalTicks","getTotalTicks","resolutionMultiplier","reduce","voice","equals","getMode","Voice","Mode","STRICT","isComplete","Fraction","LCM","getResolutionMultiplier","tickToContextMap","tickList","contexts","forEach","voiceIndex","ticksUsed","getTickables","tickable","integerTicks","numerator","newContext","tickID","push","add","getTicks","map","array","list","SortAndUnique","a","b","SimpleFormat","x","paddingBetween","addToModifierContext","ModifierContext","tick","TickContext","addTickable","preFormat","metrics","getMetrics","setX","totalLeftPx","getWidth","totalRightPx","plotDebugging","ctx","formatter","xPos","y1","y2","options","stavePadding","Flow","DEFAULT_FONT_STACK","lookupMetric","contextGaps","stroke","x1","x2","color","beginPath","setStrokeStyle","setFillStyle","setLineWidth","fillRect","save","setFont","gaps","gap","fillText","round","totalCost","toFixed","totalShift","total","restore","FormatAndDraw","stave","params","auto_beam","align_rests","Merge","TIME4_4","setMode","SOFT","addTickables","beams","Beam","applyAndGetBeams","joinVoices","formatToStave","setStave","draw","beam","setContext","getBoundingBox","FormatAndDrawTab","tabstave","tabnotes","autobeam","opts","notevoice","tabvoice","StaveConnector","AlignRestsToNotes","alignAllNotes","alignTuplets","index","StaveNote","tuplet","position","getGlyph","toUpperCase","props","getKeyProps","line","setKeyLine","constructor","softmaxFactor","maxIterations","minTotalWidth","hasMinTotalWidth","tickContexts","modiferContexts","iterationsCompleted","lossHistory","alignRests","preCalculateMinTotalWidth","createTickContexts","contextList","contextMap","context","getMinTotalWidth","createModifierContexts","tContexts","getTicksUsed","clone","justifyWidth","renderingContext","shift","width","evaluate","firstContext","lastContext","calculateIdealDistances","adjustedJustifyWidth","getTickablesByVoice","backTickable","prevContext","j","backTick","backVoices","matchingVoices","Object","keys","v","maxTicks","maxNegativeShiftPx","Infinity","expectedDistance","ticks","value","thisTickable","insideLeftEdge","getX","modLeftPx","leftDisplacedHeadPx","backMetrics","insideRightEdge","notePx","modRightPx","rightDisplacedHeadPx","getVoice","softmax","fromTickable","errorPx","fromTickablePx","shiftToIdealDistances","idealDistances","centerX","spaceAccum","negativeSpaceAccum","ideal","negativeShiftPx","abs","getCenterAlignedTickables","center_x_shift","targetWidth","actualWidth","iterations","prevTick","prevMetrics","currMetrics","getFormatterMetrics","freedom","left","right","durationStats","updateStats","duration","space","stats","undefined","mean","count","simplify","toString","formatterMetrics","leftNoteEdge","rightNote","rightMetrics","rightNoteEdge","used","totalDeviation","deviation","pow","sqrt","tune","alpha","sum","arr","move","current","prev","next","nextContext","cost","t","postFormat","postFormatContexts","format","setSoftmaxFactor","padding","getNoteEndX","getNoteStartX","getContext"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements the formatting and layout algorithms that are used\n// to position notes in a voice. The algorithm can align multiple voices both\n// within a stave, and across multiple staves.\n//\n// To do this, the formatter breaks up voices into a grid of rational-valued\n// `ticks`, to which each note is assigned. Then, minimum widths are assigned\n// to each tick based on the widths of the notes and modifiers in that tick. This\n// establishes the smallest amount of space required for each tick.\n//\n// Finally, the formatter distributes the left over space proportionally to\n// all the ticks, setting the `x` values of the notes in each tick.\n//\n// See `tests/formatter_tests.js` for usage examples. The helper functions included\n// here (`FormatAndDraw`, `FormatAndDrawTab`) also serve as useful usage examples.\n\nimport { Vex } from './vex';\nimport { Beam } from './beam';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\nimport { Voice } from './voice';\nimport { StaveConnector } from './staveconnector';\nimport { StaveNote } from './stavenote';\nimport { ModifierContext } from './modifiercontext';\nimport { TickContext } from './tickcontext';\n\n// To enable logging for this class. Set `Vex.Flow.Formatter.DEBUG` to `true`.\nfunction L(...args) { if (Formatter.DEBUG) Vex.L('Vex.Flow.Formatter', args); }\n\n// Helper function to locate the next non-rest note(s).\nfunction lookAhead(notes, restLine, i, compare) {\n  // If no valid next note group, nextRestLine is same as current.\n  let nextRestLine = restLine;\n\n  // Get the rest line for next valid non-rest note group.\n  for (i += 1; i < notes.length; i += 1) {\n    const note = notes[i];\n    if (!note.isRest() && !note.shouldIgnoreTicks()) {\n      nextRestLine = note.getLineForRest();\n      break;\n    }\n  }\n\n  // Locate the mid point between two lines.\n  if (compare && restLine !== nextRestLine) {\n    const top = Math.max(restLine, nextRestLine);\n    const bot = Math.min(restLine, nextRestLine);\n    nextRestLine = Vex.MidLine(top, bot);\n  }\n  return nextRestLine;\n}\n\n// Take an array of `voices` and place aligned tickables in the same context. Returns\n// a mapping from `tick` to `ContextType`, a list of `tick`s, and the resolution\n// multiplier.\n//\n// Params:\n// * `voices`: Array of `Voice` instances.\n// * `ContextType`: A context class (e.g., `ModifierContext`, `TickContext`)\n// * `addToContext`: Function to add tickable to context.\nfunction createContexts(voices, ContextType, addToContext) {\n  if (!voices || !voices.length) {\n    throw new Vex.RERR('BadArgument', 'No voices to format');\n  }\n\n  // Find out highest common multiple of resolution multipliers.\n  // The purpose of this is to find out a common denominator\n  // for all fractional tick values in all tickables of all voices,\n  // so that the values can be expanded and the numerator used\n  // as an integer tick value.\n  const totalTicks = voices[0].getTotalTicks();\n  const resolutionMultiplier = voices.reduce((resolutionMultiplier, voice) => {\n    if (!voice.getTotalTicks().equals(totalTicks)) {\n      throw new Vex.RERR(\n        'TickMismatch', 'Voices should have same total note duration in ticks.'\n      );\n    }\n\n    if (voice.getMode() === Voice.Mode.STRICT && !voice.isComplete()) {\n      throw new Vex.RERR(\n        'IncompleteVoice', 'Voice does not have enough notes.'\n      );\n    }\n\n    return Math.max(\n      resolutionMultiplier,\n      Fraction.LCM(resolutionMultiplier, voice.getResolutionMultiplier())\n    );\n  }, 1);\n\n  // Initialize tick maps.\n  const tickToContextMap = {};\n  const tickList = [];\n  const contexts = [];\n\n  // For each voice, extract notes and create a context for every\n  // new tick that hasn't been seen before.\n  voices.forEach((voice, voiceIndex) => {\n    // Use resolution multiplier as denominator to expand ticks\n    // to suitable integer values, so that no additional expansion\n    // of fractional tick values is needed.\n    const ticksUsed = new Fraction(0, resolutionMultiplier);\n\n    voice.getTickables().forEach(tickable => {\n      const integerTicks = ticksUsed.numerator;\n\n      // If we have no tick context for this tick, create one.\n      if (!tickToContextMap[integerTicks]) {\n        const newContext = new ContextType({ tickID: integerTicks });\n        contexts.push(newContext);\n        tickToContextMap[integerTicks] = newContext;\n      }\n\n      // Add this tickable to the TickContext.\n      addToContext(tickable, tickToContextMap[integerTicks], voiceIndex);\n\n      // Maintain a sorted list of tick contexts.\n      tickList.push(integerTicks);\n      ticksUsed.add(tickable.getTicks());\n    });\n  });\n\n  return {\n    map: tickToContextMap,\n    array: contexts,\n    list: Vex.SortAndUnique(tickList, (a, b) => a - b, (a, b) => a === b),\n    resolutionMultiplier,\n  };\n}\n\nexport class Formatter {\n  // Helper function to layout \"notes\" one after the other without\n  // regard for proportions. Useful for tests and debugging.\n  static SimpleFormat(notes, x = 0, { paddingBetween = 10 } = {}) {\n    notes.reduce((x, note) => {\n      note.addToModifierContext(new ModifierContext());\n      const tick = new TickContext().addTickable(note).preFormat();\n      const metrics = tick.getMetrics();\n      tick.setX(x + metrics.totalLeftPx);\n\n      return x + tick.getWidth() + metrics.totalRightPx + paddingBetween;\n    }, x);\n  }\n\n  // Helper function to plot formatter debug info.\n  static plotDebugging(ctx, formatter, xPos, y1, y2, options) {\n    options = {\n      stavePadding: Vex.Flow.DEFAULT_FONT_STACK[0].lookupMetric('stave.padding'),\n      ...options,\n    };\n\n    const x = xPos + options.stavePadding;\n    const contextGaps = formatter.contextGaps;\n    function stroke(x1, x2, color) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(1);\n      ctx.fillRect(x1, y1, Math.max(x2 - x1, 0), y2 - y1);\n    }\n\n    ctx.save();\n    ctx.setFont('Arial', 8, '');\n\n    contextGaps.gaps.forEach(gap => {\n      stroke(x + gap.x1, x + gap.x2, 'rgba(100,200,100,0.4)');\n      ctx.setFillStyle('green');\n      ctx.fillText(Math.round(gap.x2 - gap.x1), x + gap.x1, y2 + 12);\n    });\n\n    ctx.setFillStyle('red');\n    ctx.fillText(`Loss: ${(formatter.totalCost || 0).toFixed(2)} Shift: ${(formatter.totalShift || 0).toFixed(2)} Gap: ${contextGaps.total.toFixed(2)}`, x - 20, y2 + 27);\n    ctx.restore();\n  }\n\n  // Helper function to format and draw a single voice. Returns a bounding\n  // box for the notation.\n  //\n  // Parameters:\n  // * `ctx` - The rendering context\n  // * `stave` - The stave to which to draw (`Stave` or `TabStave`)\n  // * `notes` - Array of `Note` instances (`StaveNote`, `TextNote`, `TabNote`, etc.)\n  // * `params` - One of below:\n  //    * Setting `autobeam` only `(context, stave, notes, true)` or\n  //      `(ctx, stave, notes, {autobeam: true})`\n  //    * Setting `align_rests` a struct is needed `(context, stave, notes, {align_rests: true})`\n  //    * Setting both a struct is needed `(context, stave, notes, {\n  //      autobeam: true, align_rests: true})`\n  //\n  // `autobeam` automatically generates beams for the notes.\n  // `align_rests` aligns rests with nearby notes.\n  static FormatAndDraw(ctx, stave, notes, params) {\n    const options = {\n      auto_beam: false,\n      align_rests: false,\n    };\n\n    if (typeof params === 'object') {\n      Vex.Merge(options, params);\n    } else if (typeof params === 'boolean') {\n      options.auto_beam = params;\n    }\n\n    // Start by creating a voice and adding all the notes to it.\n    const voice = new Voice(Flow.TIME4_4)\n      .setMode(Voice.Mode.SOFT)\n      .addTickables(notes);\n\n    // Then create beams, if requested.\n    const beams = options.auto_beam ? Beam.applyAndGetBeams(voice) : [];\n\n    // Instantiate a `Formatter` and format the notes.\n    new Formatter()\n      .joinVoices([voice], { align_rests: options.align_rests })\n      .formatToStave([voice], stave, { align_rests: options.align_rests, stave });\n\n    // Render the voice and beams to the stave.\n    voice.setStave(stave).draw(ctx, stave);\n    beams.forEach(beam => beam.setContext(ctx).draw());\n\n    // Return the bounding box of the voice.\n    return voice.getBoundingBox();\n  }\n\n  // Helper function to format and draw aligned tab and stave notes in two\n  // separate staves.\n  //\n  // Parameters:\n  // * `ctx` - The rendering context\n  // * `tabstave` - A `TabStave` instance on which to render `TabNote`s.\n  // * `stave` - A `Stave` instance on which to render `Note`s.\n  // * `notes` - Array of `Note` instances for the stave (`StaveNote`, `BarNote`, etc.)\n  // * `tabnotes` - Array of `Note` instances for the tab stave (`TabNote`, `BarNote`, etc.)\n  // * `autobeam` - Automatically generate beams.\n  // * `params` - A configuration object:\n  //    * `autobeam` automatically generates beams for the notes.\n  //    * `align_rests` aligns rests with nearby notes.\n  static FormatAndDrawTab(ctx, tabstave, stave, tabnotes, notes, autobeam, params) {\n    const opts = {\n      auto_beam: autobeam,\n      align_rests: false,\n    };\n\n    if (typeof params === 'object') {\n      Vex.Merge(opts, params);\n    } else if (typeof params === 'boolean') {\n      opts.auto_beam = params;\n    }\n\n    // Create a `4/4` voice for `notes`.\n    const notevoice = new Voice(Flow.TIME4_4)\n      .setMode(Voice.Mode.SOFT)\n      .addTickables(notes);\n\n    // Create a `4/4` voice for `tabnotes`.\n    const tabvoice = new Voice(Flow.TIME4_4)\n      .setMode(Voice.Mode.SOFT)\n      .addTickables(tabnotes);\n\n    // Then create beams, if requested.\n    const beams = opts.auto_beam ? Beam.applyAndGetBeams(notevoice) : [];\n\n    // Instantiate a `Formatter` and align tab and stave notes.\n    new Formatter()\n      .joinVoices([notevoice], { align_rests: opts.align_rests })\n      .joinVoices([tabvoice])\n      .formatToStave([notevoice, tabvoice], stave, { align_rests: opts.align_rests });\n\n    // Render voices and beams to staves.\n    notevoice.draw(ctx, stave);\n    tabvoice.draw(ctx, tabstave);\n    beams.forEach(beam => beam.setContext(ctx).draw());\n\n    // Draw a connector between tab and note staves.\n    new StaveConnector(stave, tabstave).setContext(ctx).draw();\n  }\n\n  // Auto position rests based on previous/next note positions.\n  //\n  // Params:\n  // * `notes`: An array of notes.\n  // * `alignAllNotes`: If set to false, only aligns non-beamed notes.\n  // * `alignTuplets`: If set to false, ignores tuplets.\n  static AlignRestsToNotes(notes, alignAllNotes, alignTuplets) {\n    notes.forEach((note, index) => {\n      if (note instanceof StaveNote && note.isRest()) {\n        if (note.tuplet && !alignTuplets) return;\n\n        // If activated rests not on default can be rendered as specified.\n        const position = note.getGlyph().position.toUpperCase();\n        if (position !== 'R/4' && position !== 'B/4') return;\n\n        if (alignAllNotes || note.beam != null) {\n          // Align rests with previous/next notes.\n          const props = note.getKeyProps()[0];\n          if (index === 0) {\n            props.line = lookAhead(notes, props.line, index, false);\n            note.setKeyLine(0, props.line);\n          } else if (index > 0 && index < notes.length) {\n            // If previous note is a rest, use its line number.\n            let restLine;\n            if (notes[index - 1].isRest()) {\n              restLine = notes[index - 1].getKeyProps()[0].line;\n              props.line = restLine;\n            } else {\n              restLine = notes[index - 1].getLineForRest();\n              // Get the rest line for next valid non-rest note group.\n              props.line = lookAhead(notes, restLine, index, true);\n            }\n            note.setKeyLine(0, props.line);\n          }\n        }\n      }\n    });\n\n    return this;\n  }\n\n  constructor(options) {\n    this.options = {\n      softmaxFactor: null,\n      maxIterations: 2,\n      ...options\n    };\n\n    // Minimum width required to render all the notes in the voices.\n    this.minTotalWidth = 0;\n\n    // This is set to `true` after `minTotalWidth` is calculated.\n    this.hasMinTotalWidth = false;\n\n    // Total number of ticks in the voice.\n    this.totalTicks = new Fraction(0, 1);\n\n    // Arrays of tick and modifier contexts.\n    this.tickContexts = null;\n    this.modiferContexts = null;\n\n    // Gaps between contexts, for free movement of notes post\n    // formatting.\n    this.contextGaps = {\n      total: 0,\n      gaps: [],\n    };\n\n    this.voices = [];\n    this.iterationsCompleted = 0;\n    this.lossHistory = [];\n  }\n\n  // Find all the rests in each of the `voices` and align them\n  // to neighboring notes. If `alignAllNotes` is `false`, then only\n  // align non-beamed notes.\n  alignRests(voices, alignAllNotes) {\n    if (!voices || !voices.length) {\n      throw new Vex.RERR('BadArgument', 'No voices to format rests');\n    }\n\n    voices.forEach(voice =>\n      Formatter.AlignRestsToNotes(voice.getTickables(), alignAllNotes));\n  }\n\n  // Calculate the minimum width required to align and format `voices`.\n  preCalculateMinTotalWidth(voices) {\n    // Cache results.\n    if (this.hasMinTotalWidth) return this.minTotalWidth;\n\n    // Create tick contexts if not already created.\n    if (!this.tickContexts) {\n      if (!voices) {\n        throw new Vex.RERR(\n          'BadArgument', \"'voices' required to run preCalculateMinTotalWidth\"\n        );\n      }\n\n      this.createTickContexts(voices);\n    }\n\n    const { list: contextList, map: contextMap } = this.tickContexts;\n\n    // Go through each tick context and calculate total width.\n    this.minTotalWidth = contextList\n      .map(tick => {\n        const context = contextMap[tick];\n        context.preFormat();\n        return context.getWidth();\n      })\n      .reduce((a, b) => a + b, 0);\n\n    this.hasMinTotalWidth = true;\n\n    return this.minTotalWidth;\n  }\n\n  // Get minimum width required to render all voices. Either `format` or\n  // `preCalculateMinTotalWidth` must be called before this method.\n  getMinTotalWidth() {\n    if (!this.hasMinTotalWidth) {\n      throw new Vex.RERR(\n        'NoMinTotalWidth',\n        \"Call 'preCalculateMinTotalWidth' or 'preFormat' before calling 'getMinTotalWidth'\"\n      );\n    }\n\n    return this.minTotalWidth;\n  }\n\n  // Create `ModifierContext`s for each tick in `voices`.\n  createModifierContexts(voices) {\n    const contexts = createContexts(\n      voices,\n      ModifierContext,\n      (tickable, context) => tickable.addToModifierContext(context)\n    );\n\n    this.modiferContexts = contexts;\n    return contexts;\n  }\n\n  // Create `TickContext`s for each tick in `voices`. Also calculate the\n  // total number of ticks in voices.\n  createTickContexts(voices) {\n    const contexts = createContexts(\n      voices,\n      TickContext,\n      (tickable, context, voiceIndex) => context.addTickable(tickable, voiceIndex)\n    );\n\n    contexts.array.forEach(context => {\n      context.tContexts = contexts.array;\n    });\n\n    this.totalTicks = voices[0].getTicksUsed().clone();\n    this.tickContexts = contexts;\n    return contexts;\n  }\n\n  // This is the core formatter logic. Format voices and justify them\n  // to `justifyWidth` pixels. `renderingContext` is required to justify elements\n  // that can't retreive widths without a canvas. This method sets the `x` positions\n  // of all the tickables/notes in the formatter.\n  preFormat(justifyWidth = 0, renderingContext, voices, stave) {\n    // Initialize context maps.\n    const contexts = this.tickContexts;\n    const { list: contextList, map: contextMap } = contexts;\n\n    // Reset loss history for evaluator.\n    this.lossHistory = [];\n\n    // If voices and a stave were provided, set the Stave for each voice\n    // and preFormat to apply Y values to the notes;\n    if (voices && stave) {\n      voices.forEach(voice => voice.setStave(stave).preFormat());\n    }\n\n    // Now distribute the ticks to each tick context, and assign them their\n    // own X positions.\n    let x = 0;\n    let shift = 0;\n    this.minTotalWidth = 0;\n\n    // Pass 1: Give each note maximum width requested by context.\n    contextList.forEach((tick) => {\n      const context = contextMap[tick];\n      if (renderingContext) context.setContext(renderingContext);\n\n      // Make sure that all tickables in this context have calculated their\n      // space requirements.\n      context.preFormat();\n\n      const width = context.getWidth();\n      this.minTotalWidth += width;\n\n      const metrics = context.getMetrics();\n      x = x + shift + metrics.totalLeftPx;\n      context.setX(x);\n\n      // Calculate shift for the next tick.\n      shift = width - metrics.totalLeftPx;\n    });\n\n    this.minTotalWidth = x + shift;\n    this.hasMinTotalWidth = true;\n\n    // No justification needed. End formatting.\n    if (justifyWidth <= 0) return this.evaluate();\n\n\n    // Start justification. Subtract the right extra pixels of the final context because the formatter\n    // justifies based on the context's X position, which is the left-most part of the note head.\n    const firstContext = contextMap[contextList[0]];\n    const lastContext = contextMap[contextList[contextList.length - 1]];\n\n    // Calculate the \"distance error\" between the tick contexts. The expected distance is the spacing proportional to\n    // the softmax of the ticks.\n    function calculateIdealDistances(adjustedJustifyWidth) {\n      return contextList.map((tick, i) => {\n        const context = contextMap[tick];\n        const voices = context.getTickablesByVoice();\n        let backTickable = null;\n        if (i > 0) {\n          const prevContext = contextMap[contextList[i - 1]];\n          // Go through each tickable and search backwards for another tickable\n          // in the same voice. If found, use that duration (ticks) to calculate\n          // the expected distance.\n          for (let j = i - 1; j >= 0; j--) {\n            const backTick = contextMap[contextList[j]];\n            const backVoices = backTick.getTickablesByVoice();\n\n            // Look for matching voices between tick contexts.\n            const matchingVoices = [];\n            Object.keys(voices).forEach(v => {\n              if (backVoices[v]) {\n                matchingVoices.push(v);\n              }\n            });\n\n            if (matchingVoices.length > 0) {\n              // Found matching voices, get largest duration\n              let maxTicks = 0;\n              let maxNegativeShiftPx = Infinity;\n              let expectedDistance = 0;\n\n              // eslint-disable-next-line\n              matchingVoices.forEach(v => {\n                const ticks = backVoices[v].getTicks().value();\n                if (ticks > maxTicks) {\n                  backTickable = backVoices[v];\n                  maxTicks = ticks;\n                }\n\n                // Calculate the limits of the shift based on modifiers, etc.\n                const thisTickable = voices[v];\n                const insideLeftEdge = thisTickable.getX() - (thisTickable.getMetrics().modLeftPx + thisTickable.getMetrics().leftDisplacedHeadPx);\n\n                const backMetrics = backVoices[v].getMetrics();\n                const insideRightEdge = backVoices[v].getX() + backMetrics.notePx + backMetrics.modRightPx + backMetrics.rightDisplacedHeadPx;\n\n                // Don't allow shifting if notes in the same voice can collide\n                maxNegativeShiftPx = Math.min(maxNegativeShiftPx, insideLeftEdge - insideRightEdge);\n              });\n\n              // Don't shift further left than the notehead of the last context\n              maxNegativeShiftPx = Math.min(maxNegativeShiftPx, context.getX() - prevContext.getX());\n\n              // Calculate the expected distance of the current context from the last matching tickable. The\n              // distance is scaled down by the softmax for the voice.\n              expectedDistance = backTickable.getVoice().softmax(maxTicks) * adjustedJustifyWidth;\n\n              return {\n                expectedDistance,\n                maxNegativeShiftPx,\n                fromTickable: backTickable,\n              };\n            }\n          }\n        }\n\n        return { errorPx: 0, fromTickablePx: 0, maxNegativeShiftPx: 0 };\n      });\n    }\n\n\n    function shiftToIdealDistances(idealDistances) {\n      // Distribute ticks to the contexts based on the calculated distance error.\n      const centerX = adjustedJustifyWidth / 2;\n      let spaceAccum = 0;\n      let negativeSpaceAccum = 0;\n\n      contextList.forEach((tick, index) => {\n        const context = contextMap[tick];\n        if (index > 0) {\n          const x = context.getX();\n          const ideal = idealDistances[index];\n          const errorPx = (ideal.fromTickable.getX() + ideal.expectedDistance) - (x + spaceAccum);\n\n          let negativeShiftPx = 0;\n          if (errorPx > 0) {\n            spaceAccum += errorPx;\n          } else if (errorPx < 0) {\n            negativeShiftPx = Math.min(ideal.maxNegativeShiftPx + negativeSpaceAccum, Math.abs(errorPx));\n          }\n\n          context.setX(x + spaceAccum - negativeShiftPx);\n          negativeSpaceAccum += negativeShiftPx;\n        }\n\n        // Move center aligned tickables to middle\n        context.getCenterAlignedTickables().forEach(tickable => { // eslint-disable-line\n          tickable.center_x_shift = centerX - context.getX();\n        });\n      });\n\n      return lastContext.getX() - firstContext.getX();\n    }\n\n\n    const adjustedJustifyWidth = justifyWidth -\n      lastContext.getMetrics().notePx -\n      lastContext.getMetrics().totalRightPx -\n      firstContext.getMetrics().totalLeftPx;\n    let targetWidth = adjustedJustifyWidth;\n    let actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n\n    let iterations = this.options.maxIterations;\n    while (actualWidth > (adjustedJustifyWidth + lastContext.getMetrics().notePx) && iterations > 0) {\n      // If we couldn't fit all the notes into the jusification width, it's because the softmax-scaled\n      // widths between different durations differ across stave (e.g., 1 quarter note is not the same pixel-width\n      // as 4 16th-notes). Run another pass, now that we know how much to justify.\n      targetWidth -= (actualWidth - targetWidth);\n      actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n      iterations--;\n    }\n\n    // Just one context. Done formatting.\n    if (contextList.length === 1) return null;\n\n    this.justifyWidth = justifyWidth;\n    return this.evaluate();\n  }\n\n  // Calculate the total cost of this formatting decision.\n  evaluate() {\n    const justifyWidth = this.justifyWidth;\n    // Calculate available slack per tick context. This works out how much freedom\n    // to move a context has in either direction, without affecting other notes.\n    this.contextGaps = { total: 0, gaps: [] };\n    this.tickContexts.list.forEach((tick, index) => {\n      if (index === 0) return;\n      const prevTick = this.tickContexts.list[index - 1];\n      const prevContext = this.tickContexts.map[prevTick];\n      const context = this.tickContexts.map[tick];\n      const prevMetrics = prevContext.getMetrics();\n      const currMetrics = context.getMetrics();\n\n      // Calculate X position of right edge of previous note\n      const insideRightEdge = prevContext.getX() + prevMetrics.notePx + prevMetrics.totalRightPx;\n      // Calculate X position of left edge of current note\n      const insideLeftEdge = context.getX() - (currMetrics.totalLeftPx);\n      const gap = insideLeftEdge - insideRightEdge;\n      this.contextGaps.total += gap;\n      this.contextGaps.gaps.push({ x1: insideRightEdge, x2: insideLeftEdge });\n\n      // Tell the tick contexts how much they can reposition themselves.\n      context.getFormatterMetrics().freedom.left = gap;\n      prevContext.getFormatterMetrics().freedom.right = gap;\n    });\n\n    // Calculate mean distance in each voice for each duration type, then calculate\n    // how far each note is from the mean.\n    const durationStats = this.durationStats = {};\n\n    function updateStats(duration, space) {\n      const stats = durationStats[duration];\n      if (stats === undefined) {\n        durationStats[duration] = { mean: space, count: 1 };\n      } else {\n        stats.count += 1;\n        stats.mean = (stats.mean + space) / 2;\n      }\n    }\n\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach((note, i, notes) => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getMetrics();\n        const formatterMetrics = note.getFormatterMetrics();\n        const leftNoteEdge = note.getX() + metrics.notePx + metrics.totalRightPx;\n        let space = 0;\n\n        if (i < (notes.length - 1)) {\n          const rightNote = notes[i + 1];\n          const rightMetrics = rightNote.getMetrics();\n          const rightNoteEdge = rightNote.getX() - rightMetrics.totalLeftPx;\n\n          space = rightNoteEdge - leftNoteEdge;\n          formatterMetrics.space.used = rightNote.getX() - note.getX();\n          rightNote.getFormatterMetrics().freedom.left = space;\n        } else {\n          space = justifyWidth - leftNoteEdge;\n          formatterMetrics.space.used = justifyWidth - note.getX();\n        }\n\n        formatterMetrics.freedom.right = space;\n        updateStats(duration, formatterMetrics.space.used);\n      });\n    });\n\n    // Calculate how much each note deviates from the mean. Loss function is square\n    // root of the sum of squared deviations.\n    let totalDeviation = 0;\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach((note) => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getFormatterMetrics();\n\n        metrics.space.mean = durationStats[duration].mean;\n        metrics.duration = duration;\n        metrics.iterations += 1;\n        metrics.space.deviation = metrics.space.used - metrics.space.mean;\n\n        totalDeviation += Math.pow(metrics.space.deviation, 2);\n      });\n    });\n\n    this.totalCost = Math.sqrt(totalDeviation);\n    this.lossHistory.push(this.totalCost);\n    return this.totalCost;\n  }\n\n  // Run a single iteration of rejustification. At a high level, this method calculates\n  // the overall \"loss\" (or cost) of this layout, and repositions tickcontexts in an\n  // attempt to reduce the cost. You can call this method multiple times until it finds\n  // and oscillates around a global minimum.\n  //\n  // Alpha is the \"learning rate\" for the formatter. It determines how much of a shift\n  // the formatter should make based on its cost function.\n  tune(options) {\n    options = {\n      alpha: 0.5,\n      ...options,\n    };\n\n    const sum = (arr) => arr.reduce((a, b) => a + b);\n\n    // Move `current` tickcontext by `shift` pixels, and adjust the freedom\n    // on adjacent tickcontexts.\n    function move(current, prev, next, shift) {\n      current.setX(current.getX() + shift);\n      current.getFormatterMetrics().freedom.left += shift;\n      current.getFormatterMetrics().freedom.right -= shift;\n\n      if (prev) prev.getFormatterMetrics().freedom.right += shift;\n      if (next) next.getFormatterMetrics().freedom.left -= shift;\n    }\n\n    let shift = 0;\n    this.totalShift = 0;\n    this.tickContexts.list.forEach((tick, index, list) => {\n      const context = this.tickContexts.map[tick];\n      const prevContext = (index > 0) ? this.tickContexts.map[list[index - 1]] : null;\n      const nextContext = (index < list.length - 1) ? this.tickContexts.map[list[index + 1]] : null;\n\n      move(context, prevContext, nextContext, shift);\n\n      const cost = -sum(\n        context.getTickables().map(t => t.getFormatterMetrics().space.deviation));\n\n      if (cost > 0) {\n        shift = -Math.min(context.getFormatterMetrics().freedom.right, Math.abs(cost));\n      } else if (cost < 0) {\n        if (nextContext) {\n          shift = Math.min(nextContext.getFormatterMetrics().freedom.right, Math.abs(cost));\n        } else {\n          shift = 0;\n        }\n      }\n\n      shift *= options.alpha;\n      this.totalShift += shift;\n    });\n\n    this.iterationsCompleted++;\n    return this.evaluate();\n  }\n\n  // This is the top-level call for all formatting logic completed\n  // after `x` *and* `y` values have been computed for the notes\n  // in the voices.\n  postFormat() {\n    const postFormatContexts = (contexts) =>\n      contexts.list.forEach(tick => contexts.map[tick].postFormat());\n\n    postFormatContexts(this.modiferContexts);\n    postFormatContexts(this.tickContexts);\n\n    return this;\n  }\n\n  // Take all `voices` and create `ModifierContext`s out of them. This tells\n  // the formatters that the voices belong on a single stave.\n  joinVoices(voices) {\n    this.createModifierContexts(voices);\n    this.hasMinTotalWidth = false;\n    return this;\n  }\n\n  // Align rests in voices, justify the contexts, and position the notes\n  // so voices are aligned and ready to render onto the stave. This method\n  // mutates the `x` positions of all tickables in `voices`.\n  //\n  // Voices are full justified to fit in `justifyWidth` pixels.\n  //\n  // Set `options.context` to the rendering context. Set `options.align_rests`\n  // to true to enable rest alignment.\n  format(voices, justifyWidth, options) {\n    const opts = {\n      align_rests: false,\n      context: null,\n      stave: null,\n      ...options,\n    };\n\n    this.voices = voices;\n    if (this.options.softmaxFactor) {\n      this.voices.forEach(v => v.setSoftmaxFactor(this.options.softmaxFactor));\n    }\n\n    this.alignRests(voices, opts.align_rests);\n    this.createTickContexts(voices);\n    this.preFormat(justifyWidth, opts.context, voices, opts.stave);\n\n    // Only postFormat if a stave was supplied for y value formatting\n    if (opts.stave) this.postFormat();\n\n    return this;\n  }\n\n  // This method is just like `format` except that the `justifyWidth` is inferred\n  // from the `stave`.\n  formatToStave(voices, stave, options) {\n    options = {\n      padding: 10,\n      ...options\n    };\n\n    const justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - options.padding;\n    L('Formatting voices to width: ', justifyWidth);\n    return this.format(voices, justifyWidth, { context: stave.getContext(), ...options });\n  }\n}\n"],"file":"formatter.js"}