{"version":3,"sources":["../../../node_modules/vexflow/src/beam.js"],"names":["calculateStemDirection","notes","lineSum","forEach","note","keyProps","keyProp","line","Stem","DOWN","UP","getStemSlope","firstNote","lastNote","firstStemTipY","getStemExtents","topY","firstStemX","getStemX","lastStemTipY","lastStemX","BEAM_LEFT","BEAM_RIGHT","BEAM_BOTH","Beam","Element","getDefaultBeamGroups","time_sig","defaults","groups","undefined","beatTotal","parseInt","split","beatValue","tripleMeter","Fraction","map","group","parse","applyAndGetBeams","voice","stem_direction","generateBeams","getTickables","config","length","tickGroups","multiply","Vex","RuntimeError","clone","Flow","RESOLUTION","unprocessedNotes","currentTickGroup","noteGroups","currentGroup","getTotalTicks","vf_notes","reduce","memo","getTicks","add","nextTickGroup","createGroups","nextGroup","unprocessedNote","shouldIgnoreTicks","push","ticksPerGroup","totalTicks","unbeamable","durationToNumber","duration","tuplet","numerator","greaterThan","pop","equals","getBeamGroups","filter","beamable","getIntrinsicTicks","durationToTicks","sanitizeGroups","sanitizedGroups","tempGroup","index","isFirstOrLast","prevNote","breaksOnEachRest","beam_rests","isRest","breaksOnFirstOrLastRest","beam_middle_only","breakOnStemChange","maintain_stem_directions","prevDirection","getStemDirection","currentDirection","isUnbeamableDuration","shouldBreak","formatStems","stemDirection","findFirstNote","applyStemDirection","i","direction","setStemDirection","getTuplets","uniqueTuplets","beamedNoteGroups","allTuplets","beams","beam","show_stemlets","render_options","secondary_breaks","secondary_break_ticks","flat_beams","flat_beam_offset","Tuplet","LOCATION_BOTTOM","LOCATION_TOP","setTupletLocation","bracketed","setBracketed","constructor","auto_stem","setAttribute","ticks","hasStem","getCategory","stem_weight","setBeam","postFormatted","beam_count","getBeamCount","break_on_indices","beam_width","max_slope","min_slope","slope_iterations","slope_cost","stemlet_extension","partial_beam_length","min_flat_beam_offset","getNotes","beamCounts","getGlyph","maxBeamCount","max","beamCount","breakSecondaryAt","indices","getSlopeY","x","first_x_px","first_y_px","slope","calculateSlope","initialSlope","increment","minCost","Number","MAX_VALUE","bestSlope","yShift","totalStemExtension","yShiftTemp","adjustedStemTipY","stemTipY","diff","Math","abs","idealSlope","distanceFromIdeal","cost","y_shift","calculateFlatSlope","total","extremeY","extremeBeamCount","currentExtreme","getYs","min","offset","beamWidth","extremeTest","newOffset","getBeamYToDraw","beamY","applyStemExtensions","stemX","beamedStemTipY","preBeamExtension","getStem","getExtension","beamExtension","stem","setExtension","renderHeightAdjustment","WIDTH","totalBeamWidth","setVisibility","setStemlet","lookupBeamDirection","prev_tick","tick","next_tick","lookup_duration","prev_note_gets_beam","next_note_gets_beam","note_gets_beam","getBeamLines","tick_of_duration","beam_lines","beam_started","current_beam","previous_should_break","tick_tally","value","should_break","indexOf","stem_x","prev_note","next_note","beam_alone","end","start","beam_direction","includes","last_beam","drawStems","setContext","context","draw","drawBeamLines","checkContext","valid_beam_durations","beamThickness","beamLines","j","beam_line","startBeamX","startBeamY","lastBeamX","lastBeamY","beginPath","moveTo","lineTo","closePath","fill","preFormat","postFormat","setRendered","applyStyle","restoreStyle"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `Beams` that span over a set of `StemmableNotes`.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Element } from './element';\nimport { Fraction } from './fraction';\nimport { Tuplet } from './tuplet';\nimport { Stem } from './stem';\n\nfunction calculateStemDirection(notes) {\n  let lineSum = 0;\n  notes.forEach(note => {\n    if (note.keyProps) {\n      note.keyProps.forEach(keyProp => {\n        lineSum += (keyProp.line - 3);\n      });\n    }\n  });\n\n  if (lineSum >= 0) {\n    return Stem.DOWN;\n  }\n  return Stem.UP;\n}\n\nconst getStemSlope = (firstNote, lastNote) => {\n  const firstStemTipY = firstNote.getStemExtents().topY;\n  const firstStemX = firstNote.getStemX();\n  const lastStemTipY = lastNote.getStemExtents().topY;\n  const lastStemX = lastNote.getStemX();\n  return (lastStemTipY - firstStemTipY) / (lastStemX - firstStemX);\n};\n\nconst BEAM_LEFT = 'L';\nconst BEAM_RIGHT = 'R';\nconst BEAM_BOTH = 'B';\n\nexport class Beam extends Element {\n  // Gets the default beam groups for a provided time signature.\n  // Attempts to guess if the time signature is not found in table.\n  // Currently this is fairly naive.\n  static getDefaultBeamGroups(time_sig) {\n    if (!time_sig || time_sig === 'c') {\n      time_sig = '4/4';\n    }\n\n    const defaults = {\n      '1/2': ['1/2'],\n      '2/2': ['1/2'],\n      '3/2': ['1/2'],\n      '4/2': ['1/2'],\n\n      '1/4': ['1/4'],\n      '2/4': ['1/4'],\n      '3/4': ['1/4'],\n      '4/4': ['1/4'],\n\n      '1/8': ['1/8'],\n      '2/8': ['2/8'],\n      '3/8': ['3/8'],\n      '4/8': ['2/8'],\n\n      '1/16': ['1/16'],\n      '2/16': ['2/16'],\n      '3/16': ['3/16'],\n      '4/16': ['2/16'],\n    };\n\n    const groups = defaults[time_sig];\n\n    if (groups === undefined) {\n      // If no beam groups found, naively determine\n      // the beam groupings from the time signature\n      const beatTotal = parseInt(time_sig.split('/')[0], 10);\n      const beatValue = parseInt(time_sig.split('/')[1], 10);\n\n      const tripleMeter = beatTotal % 3 === 0;\n\n      if (tripleMeter) {\n        return [new Fraction(3, beatValue)];\n      } else if (beatValue > 4) {\n        return [new Fraction(2, beatValue)];\n      } else if (beatValue <= 4) {\n        return [new Fraction(1, beatValue)];\n      }\n    } else {\n      return groups.map(group => new Fraction().parse(group));\n    }\n\n    return [new Fraction(1, 4)];\n  }\n\n  // A helper function to automatically build basic beams for a voice. For more\n  // complex auto-beaming use `Beam.generateBeams()`.\n  //\n  // Parameters:\n  // * `voice` - The voice to generate the beams for\n  // * `stem_direction` - A stem direction to apply to the entire voice\n  // * `groups` - An array of `Fraction` representing beat groupings for the beam\n  static applyAndGetBeams(voice, stem_direction, groups) {\n    return Beam.generateBeams(voice.getTickables(), {\n      groups,\n      stem_direction,\n    });\n  }\n\n  // A helper function to autimatically build beams for a voice with\n  // configuration options.\n  //\n  // Example configuration object:\n  //\n  // ```\n  // config = {\n  //   groups: [new Vex.Flow.Fraction(2, 8)],\n  //   stem_direction: -1,\n  //   beam_rests: true,\n  //   beam_middle_only: true,\n  //   show_stemlets: false\n  // };\n  // ```\n  //\n  // Parameters:\n  // * `notes` - An array of notes to create the beams for\n  // * `config` - The configuration object\n  //    * `groups` - Array of `Fractions` that represent the beat structure to beam the notes\n  //    * `stem_direction` - Set to apply the same direction to all notes\n  //    * `beam_rests` - Set to `true` to include rests in the beams\n  //    * `beam_middle_only` - Set to `true` to only beam rests in the middle of the beat\n  //    * `show_stemlets` - Set to `true` to draw stemlets for rests\n  //    * `maintain_stem_directions` - Set to `true` to not apply new stem directions\n  //\n  static generateBeams(notes, config) {\n    if (!config) config = {};\n\n    if (!config.groups || !config.groups.length) {\n      config.groups = [new Fraction(2, 8)];\n    }\n\n    // Convert beam groups to tick amounts\n    const tickGroups = config.groups.map(group => {\n      if (!group.multiply) {\n        throw new Vex.RuntimeError('InvalidBeamGroups',\n          'The beam groups must be an array of Vex.Flow.Fractions');\n      }\n      return group.clone().multiply(Flow.RESOLUTION, 1);\n    });\n\n    const unprocessedNotes = notes;\n    let currentTickGroup = 0;\n    let noteGroups = [];\n    let currentGroup = [];\n\n    function getTotalTicks(vf_notes) {\n      return vf_notes.reduce((memo, note) => note.getTicks().clone().add(memo), new Fraction(0, 1));\n    }\n\n    function nextTickGroup() {\n      if (tickGroups.length - 1 > currentTickGroup) {\n        currentTickGroup += 1;\n      } else {\n        currentTickGroup = 0;\n      }\n    }\n\n    function createGroups() {\n      let nextGroup = [];\n\n      unprocessedNotes.forEach(unprocessedNote => {\n        nextGroup = [];\n        if (unprocessedNote.shouldIgnoreTicks()) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          return; // Ignore untickables (like bar notes)\n        }\n\n        currentGroup.push(unprocessedNote);\n        const ticksPerGroup = tickGroups[currentTickGroup].clone();\n        const totalTicks = getTotalTicks(currentGroup);\n\n        // Double the amount of ticks in a group, if it's an unbeamable tuplet\n        const unbeamable = Flow.durationToNumber(unprocessedNote.duration) < 8;\n        if (unbeamable && unprocessedNote.tuplet) {\n          ticksPerGroup.numerator *= 2;\n        }\n\n        // If the note that was just added overflows the group tick total\n        if (totalTicks.greaterThan(ticksPerGroup)) {\n          // If the overflow note can be beamed, start the next group\n          // with it. Unbeamable notes leave the group overflowed.\n          if (!unbeamable) {\n            nextGroup.push(currentGroup.pop());\n          }\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        } else if (totalTicks.equals(ticksPerGroup)) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        }\n      });\n\n      // Adds any remainder notes\n      if (currentGroup.length > 0) {\n        noteGroups.push(currentGroup);\n      }\n    }\n\n    function getBeamGroups() {\n      return noteGroups.filter(group => {\n        if (group.length > 1) {\n          let beamable = true;\n          group.forEach(note => {\n            if (note.getIntrinsicTicks() >= Flow.durationToTicks('4')) {\n              beamable = false;\n            }\n          });\n          return beamable;\n        }\n        return false;\n      });\n    }\n\n    // Splits up groups by Rest\n    function sanitizeGroups() {\n      const sanitizedGroups = [];\n      noteGroups.forEach(group => {\n        let tempGroup = [];\n        group.forEach((note, index, group) => {\n          const isFirstOrLast = index === 0 || index === group.length - 1;\n          const prevNote = group[index - 1];\n\n          const breaksOnEachRest = !config.beam_rests && note.isRest();\n          const breaksOnFirstOrLastRest = (config.beam_rests &&\n            config.beam_middle_only && note.isRest() && isFirstOrLast);\n\n          let breakOnStemChange = false;\n          if (config.maintain_stem_directions && prevNote &&\n            !note.isRest() && !prevNote.isRest()) {\n            const prevDirection = prevNote.getStemDirection();\n            const currentDirection = note.getStemDirection();\n            breakOnStemChange = currentDirection !== prevDirection;\n          }\n\n          const isUnbeamableDuration = parseInt(note.duration, 10) < 8;\n\n          // Determine if the group should be broken at this note\n          const shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest ||\n            breakOnStemChange || isUnbeamableDuration;\n\n          if (shouldBreak) {\n            // Add current group\n            if (tempGroup.length > 0) {\n              sanitizedGroups.push(tempGroup);\n            }\n\n            // Start a new group. Include the current note if the group\n            // was broken up by stem direction, as that note needs to start\n            // the next group of notes\n            tempGroup = breakOnStemChange ? [note] : [];\n          } else {\n            // Add note to group\n            tempGroup.push(note);\n          }\n        });\n\n        // If there is a remaining group, add it as well\n        if (tempGroup.length > 0) {\n          sanitizedGroups.push(tempGroup);\n        }\n      });\n\n      noteGroups = sanitizedGroups;\n    }\n\n    function formatStems() {\n      noteGroups.forEach(group => {\n        let stemDirection;\n        if (config.maintain_stem_directions) {\n          const note = findFirstNote(group);\n          stemDirection = note ? note.getStemDirection() : Stem.UP;\n        } else {\n          if (config.stem_direction) {\n            stemDirection = config.stem_direction;\n          } else {\n            stemDirection = calculateStemDirection(group);\n          }\n        }\n        applyStemDirection(group, stemDirection);\n      });\n    }\n\n    function findFirstNote(group) {\n      for (let i = 0; i < group.length; i++) {\n        const note = group[i];\n        if (!note.isRest()) {\n          return note;\n        }\n      }\n\n      return false;\n    }\n\n    function applyStemDirection(group, direction) {\n      group.forEach(note => {\n        note.setStemDirection(direction);\n      });\n    }\n\n    // Get all of the tuplets in all of the note groups\n    function getTuplets() {\n      const uniqueTuplets = [];\n\n      // Go through all of the note groups and inspect for tuplets\n      noteGroups.forEach(group => {\n        let tuplet = null;\n        group.forEach(note => {\n          if (note.tuplet && (tuplet !== note.tuplet)) {\n            tuplet = note.tuplet;\n            uniqueTuplets.push(tuplet);\n          }\n        });\n      });\n      return uniqueTuplets;\n    }\n\n\n    // Using closures to store the variables throughout the various functions\n    // IMO Keeps it this process lot cleaner - but not super consistent with\n    // the rest of the API's style - Silverwolf90 (Cyril)\n    createGroups();\n    sanitizeGroups();\n    formatStems();\n\n    // Get the notes to be beamed\n    const beamedNoteGroups = getBeamGroups();\n\n    // Get the tuplets in order to format them accurately\n    const allTuplets = getTuplets();\n\n    // Create a Vex.Flow.Beam from each group of notes to be beamed\n    const beams = [];\n    beamedNoteGroups.forEach(group => {\n      const beam = new Beam(group);\n\n      if (config.show_stemlets) {\n        beam.render_options.show_stemlets = true;\n      }\n      if (config.secondary_breaks) {\n        beam.render_options.secondary_break_ticks = Flow.durationToTicks(config.secondary_breaks);\n      }\n      if (config.flat_beams === true) {\n        beam.render_options.flat_beams = true;\n        beam.render_options.flat_beam_offset = config.flat_beam_offset;\n      }\n      beams.push(beam);\n    });\n\n    // Reformat tuplets\n    allTuplets.forEach(tuplet => {\n      // Set the tuplet location based on the stem direction\n      const direction = tuplet.notes[0].stem_direction === Stem.DOWN ?\n        Tuplet.LOCATION_BOTTOM : Tuplet.LOCATION_TOP;\n      tuplet.setTupletLocation(direction);\n\n      // If any of the notes in the tuplet are not beamed, draw a bracket.\n      let bracketed = false;\n      for (let i = 0; i < tuplet.notes.length; i++) {\n        const note = tuplet.notes[i];\n        if (note.beam === null) {\n          bracketed = true;\n          break;\n        }\n      }\n      tuplet.setBracketed(bracketed);\n    });\n\n    return beams;\n  }\n\n  constructor(notes, auto_stem) {\n    super();\n    this.setAttribute('type', 'Beam');\n\n    if (!notes || notes === []) {\n      throw new Vex.RuntimeError('BadArguments', 'No notes provided for beam.');\n    }\n\n    if (notes.length === 1) {\n      throw new Vex.RuntimeError('BadArguments', 'Too few notes for beam.');\n    }\n\n    // Validate beam line, direction and ticks.\n    this.ticks = notes[0].getIntrinsicTicks();\n\n    if (this.ticks >= Flow.durationToTicks('4')) {\n      throw new Vex.RuntimeError('BadArguments',\n        'Beams can only be applied to notes shorter than a quarter note.');\n    }\n\n    let i; // shared iterator\n    let note;\n\n    this.stem_direction = Stem.UP;\n\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n      if (note.hasStem()) {\n        this.stem_direction = note.getStemDirection();\n        break;\n      }\n    }\n\n    let stem_direction = this.stem_direction;\n    // Figure out optimal stem direction based on given notes\n    if (auto_stem && notes[0].getCategory() === 'stavenotes') {\n      stem_direction = calculateStemDirection(notes);\n    } else if (auto_stem && notes[0].getCategory() === 'tabnotes') {\n      // Auto Stem TabNotes\n      const stem_weight = notes.reduce((memo, note) => memo + note.stem_direction, 0);\n\n      stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;\n    }\n\n    // Apply stem directions and attach beam to notes\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n      if (auto_stem) {\n        note.setStemDirection(stem_direction);\n        this.stem_direction = stem_direction;\n      }\n      note.setBeam(this);\n    }\n\n    this.postFormatted = false;\n    this.notes = notes;\n    this.beam_count = this.getBeamCount();\n    this.break_on_indices = [];\n    this.render_options = {\n      beam_width: 5,\n      max_slope: 0.25,\n      min_slope: -0.25,\n      slope_iterations: 20,\n      slope_cost: 100,\n      show_stemlets: false,\n      stemlet_extension: 7,\n      partial_beam_length: 10,\n      flat_beams: false,\n      min_flat_beam_offset: 15,\n    };\n  }\n\n  // Get the notes in this beam\n  getNotes() { return this.notes; }\n\n  // Get the max number of beams in the set of notes\n  getBeamCount() {\n    const beamCounts = this.notes.map(note => note.getGlyph().beam_count);\n\n    const maxBeamCount = beamCounts.reduce((max, beamCount) => beamCount > max ? beamCount : max);\n\n    return maxBeamCount;\n  }\n\n  // Set which note `indices` to break the secondary beam at\n  breakSecondaryAt(indices) {\n    this.break_on_indices = indices;\n    return this;\n  }\n\n  // Return the y coordinate for linear function\n  getSlopeY(x, first_x_px, first_y_px, slope) {\n    return first_y_px + ((x - first_x_px) * slope);\n  }\n\n  // Calculate the best possible slope for the provided notes\n  calculateSlope() {\n    const {\n      notes,\n      stem_direction: stemDirection,\n      render_options: { max_slope, min_slope, slope_iterations, slope_cost },\n    } = this;\n\n    const firstNote = notes[0];\n    const initialSlope = getStemSlope(firstNote, notes[notes.length - 1]);\n    const increment = (max_slope - min_slope) / slope_iterations;\n    let minCost = Number.MAX_VALUE;\n    let bestSlope = 0;\n    let yShift = 0;\n\n    // iterate through slope values to find best weighted fit\n    for (let slope = min_slope; slope <= max_slope; slope += increment) {\n      let totalStemExtension = 0;\n      let yShiftTemp = 0;\n\n      // iterate through notes, calculating y shift and stem extension\n      for (let i = 1; i < notes.length; ++i) {\n        const note = notes[i];\n        const adjustedStemTipY = this.getSlopeY(\n          note.getStemX(),\n          firstNote.getStemX(),\n          firstNote.getStemExtents().topY,\n          slope\n        ) + yShiftTemp;\n\n        const stemTipY = note.getStemExtents().topY;\n        // beam needs to be shifted up to accommodate note\n        if (stemTipY * stemDirection < adjustedStemTipY * stemDirection) {\n          const diff = Math.abs(stemTipY - adjustedStemTipY);\n          yShiftTemp += diff * -stemDirection;\n          totalStemExtension += diff * i;\n        } else { // beam overshoots note, account for the difference\n          totalStemExtension += (stemTipY - adjustedStemTipY) * stemDirection;\n        }\n      }\n\n      // most engraving books suggest aiming for a slope about half the angle of the\n      // difference between the first and last notes' stem length;\n      const idealSlope = initialSlope / 2;\n      const distanceFromIdeal = Math.abs(idealSlope - slope);\n\n      // This tries to align most beams to something closer to the idealSlope, but\n      // doesn't go crazy. To disable, set this.render_options.slope_cost = 0\n      const cost = slope_cost * distanceFromIdeal + Math.abs(totalStemExtension);\n\n      // update state when a more ideal slope is found\n      if (cost < minCost) {\n        minCost = cost;\n        bestSlope = slope;\n        yShift = yShiftTemp;\n      }\n    }\n\n    this.slope = bestSlope;\n    this.y_shift = yShift;\n  }\n\n  // Calculate a slope and y-shift for flat beams\n  calculateFlatSlope() {\n    const {\n      notes, stem_direction,\n      render_options: { beam_width, min_flat_beam_offset, flat_beam_offset },\n    } = this;\n\n    // If a flat beam offset has not yet been supplied or calculated,\n    // generate one based on the notes in this particular note group\n    let total = 0;\n    let extremeY = 0;  // Store the highest or lowest note here\n    let extremeBeamCount = 0;  // The beam count of the extreme note\n    let currentExtreme = 0;\n    for (let i = 0; i < notes.length; i++) {\n      // Total up all of the offsets so we can average them out later\n      const note = notes[i];\n      const stemTipY = note.getStemExtents().topY;\n      total += stemTipY;\n\n      // Store the highest (stems-up) or lowest (stems-down) note so the\n      //  offset can be adjusted in case the average isn't enough\n      if (stem_direction === Stem.DOWN && currentExtreme < stemTipY) {\n        currentExtreme = stemTipY;\n        extremeY = Math.max(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      } else if (\n        stem_direction === Stem.UP && (currentExtreme === 0 || currentExtreme > stemTipY)\n      ) {\n        currentExtreme = stemTipY;\n        extremeY = Math.min(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      }\n    }\n\n    // Average the offsets to try and come up with a reasonable one that\n    //  works for all of the notes in the beam group.\n    let offset = total / notes.length;\n\n    // In case the average isn't long enough, add or subtract some more\n    //  based on the highest or lowest note (again, based on the stem\n    //  direction). This also takes into account the added height due to\n    //  the width of the beams.\n    const beamWidth = beam_width * 1.5;\n    const extremeTest = min_flat_beam_offset + (extremeBeamCount * beamWidth);\n    const newOffset = extremeY + (extremeTest * -stem_direction);\n    if (stem_direction === Stem.DOWN && offset < newOffset) {\n      offset = extremeY + extremeTest;\n    } else if (stem_direction === Stem.UP && offset > newOffset) {\n      offset = extremeY - extremeTest;\n    }\n\n    if (!flat_beam_offset) {\n      // Set the offset for the group based on the calculations above.\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.DOWN && offset > flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.UP && offset < flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    }\n\n    // for flat beams, the slope and y_shift are simply 0\n    this.slope = 0;\n    this.y_shift = 0;\n  }\n\n  getBeamYToDraw() {\n    const firstNote = this.notes[0];\n    const firstStemTipY = firstNote.getStemExtents().topY;\n    let beamY = firstStemTipY;\n\n    // For flat beams, set the first and last Y to the offset, rather than\n    //  using the note's stem extents.\n    if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {\n      beamY = this.render_options.flat_beam_offset;\n    }\n    return beamY;\n  }\n\n  // Create new stems for the notes in the beam, so that each stem\n  // extends into the beams.\n  applyStemExtensions() {\n    const {\n      notes, slope, y_shift, stem_direction, beam_count,\n      render_options: {\n        show_stemlets,\n        stemlet_extension,\n        beam_width,\n      },\n    } = this;\n\n    const firstNote = notes[0];\n    const firstStemTipY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n\n    for (let i = 0; i < notes.length; ++i) {\n      const note = notes[i];\n      const stemX = note.getStemX();\n      const { topY: stemTipY } = note.getStemExtents();\n      const beamedStemTipY = this.getSlopeY(stemX, firstStemX, firstStemTipY, slope) + y_shift;\n      const preBeamExtension = note.getStem().getExtension();\n      const beamExtension = stem_direction === Stem.UP\n        ? stemTipY - beamedStemTipY\n        : beamedStemTipY - stemTipY;\n\n      note.stem.setExtension(preBeamExtension + beamExtension);\n      note.stem.renderHeightAdjustment = -Stem.WIDTH / 2;\n\n      if (note.isRest() && show_stemlets) {\n        const beamWidth = beam_width;\n        const totalBeamWidth = ((beam_count - 1) * beamWidth * 1.5) + beamWidth;\n        note.stem\n          .setVisibility(true)\n          .setStemlet(true, totalBeamWidth + stemlet_extension);\n      }\n    }\n  }\n\n  // return upper level beam direction.\n  lookupBeamDirection(duration, prev_tick, tick, next_tick) {\n    if (duration === '4') {\n      return BEAM_LEFT;\n    }\n\n    const lookup_duration =  `${Flow.durationToNumber(duration) / 2}`;\n    const prev_note_gets_beam = prev_tick < Flow.durationToTicks(lookup_duration);\n    const next_note_gets_beam = next_tick < Flow.durationToTicks(lookup_duration);\n    const note_gets_beam = tick < Flow.durationToTicks(lookup_duration);\n\n    if (prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_BOTH;\n    } else if (prev_note_gets_beam && !next_note_gets_beam && note_gets_beam) {\n      return BEAM_LEFT;\n    } else if (!prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_RIGHT;\n    }\n\n    return this.lookupBeamDirection(lookup_duration, prev_tick, tick, next_tick);\n  }\n\n  // Get the x coordinates for the beam lines of specific `duration`\n  getBeamLines(duration) {\n    const tick_of_duration = Flow.durationToTicks(duration);\n    const beam_lines = [];\n    let beam_started = false;\n    let current_beam = null;\n    const partial_beam_length = this.render_options.partial_beam_length;\n    let previous_should_break = false;\n    let tick_tally = 0;\n    for (let i = 0; i < this.notes.length; ++i) {\n      const note = this.notes[i];\n\n      // See if we need to break secondary beams on this note.\n      const ticks = note.ticks.value();\n      tick_tally += ticks;\n      let should_break = false;\n\n      // 8th note beams are always drawn.\n      if (parseInt(duration, 10) >= 8) {\n        // First, check to see if any indices were set up through breakSecondaryAt()\n        should_break = this.break_on_indices.indexOf(i) !== -1;\n\n        // If the secondary breaks were auto-configured in the render options,\n        //  handle that as well.\n        if (this.render_options.secondary_break_ticks && tick_tally >=\n          this.render_options.secondary_break_ticks) {\n          tick_tally = 0;\n          should_break = true;\n        }\n      }\n      const note_gets_beam = note.getIntrinsicTicks() < tick_of_duration;\n\n      const stem_x = note.getStemX() - (Stem.WIDTH / 2);\n\n      // Check to see if the next note in the group will get a beam at this\n      //  level. This will help to inform the partial beam logic below.\n      const prev_note = this.notes[i - 1];\n      const next_note = this.notes[i + 1];\n      const next_note_gets_beam = next_note && next_note.getIntrinsicTicks() < tick_of_duration;\n      const prev_note_gets_beam = prev_note && prev_note.getIntrinsicTicks() < tick_of_duration;\n      const beam_alone = prev_note && next_note &&\n      note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n      // const beam_alone = note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n      if (note_gets_beam) {\n        // This note gets a beam at the current level\n        if (beam_started) {\n          // We're currently in the middle of a beam. Just continue it on to\n          //  the stem X of the current note.\n          current_beam = beam_lines[beam_lines.length - 1];\n          current_beam.end = stem_x;\n\n          // If a secondary beam break is set up, end the beam right now.\n          if (should_break) {\n            beam_started = false;\n            if (next_note && !next_note_gets_beam && current_beam.end === null) {\n              // This note gets a beam,.but the next one does not. This means\n              //  we need a partial pointing right.\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          }\n        } else {\n          // No beam started yet. Start a new one.\n          current_beam = { start: stem_x, end: null };\n          beam_started = true;\n\n          if (beam_alone) {\n            // previous and next beam exists and does not get a beam but current gets it.\n            const prev_tick = prev_note.getIntrinsicTicks();\n            const next_tick = next_note.getIntrinsicTicks();\n            const tick = note.getIntrinsicTicks();\n            const beam_direction = this.lookupBeamDirection(duration, prev_tick, tick, next_tick);\n\n            if ([BEAM_LEFT, BEAM_BOTH].includes(beam_direction)) {\n              current_beam.end = current_beam.start - partial_beam_length;\n            } else {\n              current_beam.end = current_beam.start + partial_beam_length;\n            }\n          } else if (!next_note_gets_beam) {\n            // The next note doesn't get a beam. Draw a partial.\n            if ((previous_should_break || i === 0) && next_note) {\n              // This is the first note (but not the last one), or it is\n              //  following a secondary break. Draw a partial to the right.\n              current_beam.end = current_beam.start + partial_beam_length;\n            } else {\n              // By default, draw a partial to the left.\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          } else if (should_break) {\n            // This note should have a secondary break after it. Even though\n            //  we just started a beam, it needs to end immediately.\n            current_beam.end = current_beam.start - partial_beam_length;\n            beam_started = false;\n          }\n          beam_lines.push(current_beam);\n        }\n      } else {\n        // The current note does not get a beam.\n        beam_started = false;\n      }\n\n      // Store the secondary break flag to inform the partial beam logic in\n      //  the next iteration of the loop.\n      previous_should_break = should_break;\n    }\n\n    // Add a partial beam pointing left if this is the last note in the group\n    const last_beam = beam_lines[beam_lines.length - 1];\n    if (last_beam && last_beam.end === null) {\n      last_beam.end = last_beam.start - partial_beam_length;\n    }\n    return beam_lines;\n  }\n\n  // Render the stems for each notes\n  drawStems() {\n    this.notes.forEach(note => {\n      if (note.getStem()) {\n        note.getStem().setContext(this.context).draw();\n      }\n    }, this);\n  }\n\n  // Render the beam lines\n  drawBeamLines() {\n    this.checkContext();\n\n    const valid_beam_durations = ['4', '8', '16', '32', '64'];\n\n    const firstNote = this.notes[0];\n    let beamY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n    const beamThickness = this.render_options.beam_width * this.stem_direction;\n\n    // Draw the beams.\n    for (let i = 0; i < valid_beam_durations.length; ++i) {\n      const duration = valid_beam_durations[i];\n      const beamLines = this.getBeamLines(duration);\n\n      for (let j = 0; j < beamLines.length; ++j) {\n        const beam_line = beamLines[j];\n        const startBeamX = beam_line.start;\n\n        const startBeamY = this.getSlopeY(startBeamX, firstStemX, beamY, this.slope);\n        const lastBeamX = beam_line.end;\n        const lastBeamY = this.getSlopeY(lastBeamX, firstStemX, beamY, this.slope);\n\n        this.context.beginPath();\n        this.context.moveTo(startBeamX, startBeamY);\n        this.context.lineTo(startBeamX, startBeamY + beamThickness);\n        this.context.lineTo(lastBeamX + 1, lastBeamY + beamThickness);\n        this.context.lineTo(lastBeamX + 1, lastBeamY);\n        this.context.closePath();\n        this.context.fill();\n      }\n\n      beamY += beamThickness * 1.5;\n    }\n  }\n\n  // Pre-format the beam\n  preFormat() { return this; }\n\n  // Post-format the beam. This can only be called after\n  // the notes in the beam have both `x` and `y` values. ie: they've\n  // been formatted and have staves\n  postFormat() {\n    if (this.postFormatted) return;\n\n    // Calculate a smart slope if we're not forcing the beams to be flat.\n    if (this.notes[0].getCategory() === 'tabnotes' || this.render_options.flat_beams) {\n      this.calculateFlatSlope();\n    } else {\n      this.calculateSlope();\n    }\n    this.applyStemExtensions();\n\n    this.postFormatted = true;\n  }\n\n  // Render the beam to the canvas context\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    if (this.unbeamable) return;\n\n    if (!this.postFormatted) {\n      this.postFormat();\n    }\n\n    this.drawStems();\n    this.applyStyle();\n    this.drawBeamLines();\n    this.restoreStyle();\n  }\n}\n"],"file":"beam.js"}