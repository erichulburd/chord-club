{"version":3,"sources":["../../../node_modules/vexflow/src/articulation.js"],"names":["L","args","Articulation","DEBUG","Vex","ABOVE","BELOW","Modifier","Position","roundToNearestHalf","mathFn","value","isWithinLines","line","position","getRoundingFunction","Math","ceil","floor","round","snapLineToStaff","canSitBetweenLines","offsetDirection","snappedLine","canSnapToStaffSpace","onStaffLine","HALF_STAFF_SPACE","isStaveNote","note","noteCategory","getCategory","getTopY","textLine","stave","getStave","stemDirection","getStemDirection","topY","stemTipY","baseY","stemBaseY","getStemExtents","hasStem","Stem","UP","min","getYs","getYForTopText","RERR","getBottomY","max","getYForBottomText","getInitialOffset","isOnStemTip","DOWN","CATEGORY","INITIAL_OFFSET","format","articulations","state","length","isAbove","artic","getPosition","isBelow","margin","getIncrement","articulation","glyph","getMetrics","height","filter","forEach","setTextLine","top_text_line","text_line","width","map","getWidth","reduce","maxWidth","articWidth","left_shift","right_shift","easyScoreHook","builder","articNameToCode","staccato","tenuto","split","articString","trim","name","type","PositionString","getFactory","addModifier","constructor","setAttribute","index","render_options","font_scale","reset","Flow","articulationCodes","code","aboveCode","belowCode","Glyph","setWidth","draw","between_lines","context","ctx","checkContext","setRendered","staffSpace","getSpacingBetweenLines","isTab","x","getModifierStartXY","shouldSitOutsideStaff","initialOffset","padding","musicFont","lookupMetric","getCode","y","setOrigin","noteLine","positions","str","getKeyProps","distanceFromNote","articLine","abs","render"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns.\n//\n// ## Description\n//\n// This file implements articulations and accents as modifiers that can be\n// attached to notes. The complete list of articulations is available in\n// `tables.js` under `Vex.Flow.articulationCodes`.\n//\n// See `tests/articulation_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { Glyph } from './glyph';\nimport { Stem } from './stem';\n\n// To enable logging for this class. Set `Vex.Flow.Articulation.DEBUG` to `true`.\nfunction L(...args) { if (Articulation.DEBUG) Vex.L('Vex.Flow.Articulation', args); }\n\nconst { ABOVE, BELOW } = Modifier.Position;\n\nconst roundToNearestHalf = (mathFn, value) => mathFn(value / 0.5) * 0.5;\n\n// This includes both staff and ledger lines\nconst isWithinLines = (line, position) => position === ABOVE ? line <= 5 : line >= 1;\n\nconst getRoundingFunction = (line, position) => {\n  if (isWithinLines(line, position)) {\n    if (position === ABOVE) {\n      return Math.ceil;\n    } else {\n      return Math.floor;\n    }\n  } else {\n    return Math.round;\n  }\n};\n\nconst snapLineToStaff = (canSitBetweenLines, line, position, offsetDirection) => {\n  // Initially, snap to nearest staff line or space\n  const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n  const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n  const onStaffLine = snappedLine % 1 === 0;\n\n  if (canSnapToStaffSpace && onStaffLine) {\n    const HALF_STAFF_SPACE = 0.5;\n    return snappedLine + (HALF_STAFF_SPACE * -offsetDirection);\n  } else {\n    return snappedLine;\n  }\n};\n\nconst isStaveNote = (note) => {\n  const noteCategory = note.getCategory();\n  return noteCategory === 'stavenotes' || noteCategory === 'gracenotes';\n};\n\nconst getTopY = (note, textLine) => {\n  const stave = note.getStave();\n  const stemDirection = note.getStemDirection();\n  const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n\n  if (isStaveNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stemBaseY;\n      }\n    } else {\n      return Math.min(...note.getYs());\n    }\n  } else if (note.getCategory() === 'tabnotes') {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stave.getYForTopText(textLine);\n      }\n    } else {\n      return stave.getYForTopText(textLine);\n    }\n  } else {\n    throw new Vex.RERR(\n      'UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes'\n    );\n  }\n};\n\nconst getBottomY = (note, textLine) => {\n  const stave = note.getStave();\n  const stemDirection = note.getStemDirection();\n  const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n\n  if (isStaveNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemBaseY;\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return Math.max(...note.getYs());\n    }\n  } else if (note.getCategory() === 'tabnotes') {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stave.getYForBottomText(textLine);\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return stave.getYForBottomText(textLine);\n    }\n  } else {\n    throw new Vex.RERR(\n      'UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes'\n    );\n  }\n};\n\n// Gets the initial offset of the articulation from the y value of the starting position.\n// This is required because the top/bottom text positions already have spacing applied to\n// provide a \"visually pleasent\" default position. However the y values provided from\n// the stavenote's top/bottom do *not* have any pre-applied spacing. This function\n// normalizes this asymmetry.\nconst getInitialOffset = (note, position) => {\n  const isOnStemTip = (\n    (position === ABOVE && note.getStemDirection() === Stem.UP) ||\n    (position === BELOW && note.getStemDirection() === Stem.DOWN)\n  );\n\n  if (isStaveNote(note)) {\n    if (note.hasStem() && isOnStemTip) {\n      return 0.5;\n    } else {\n      // this amount is larger than the stem-tip offset because we start from\n      // the center of the notehead\n      return 1;\n    }\n  } else {\n    if (note.hasStem() && isOnStemTip) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n};\n\nexport class Articulation extends Modifier {\n  static get CATEGORY() { return 'articulations'; }\n  static get INITIAL_OFFSET() { return -0.5; }\n\n  // FIXME:\n  // Most of the complex formatting logic (ie: snapping to space) is\n  // actually done in .render(). But that logic belongs in this method.\n  //\n  // Unfortunately, this isn't possible because, by this point, stem lengths\n  // have not yet been finalized. Finalized stem lengths are required to determine the\n  // initial position of any stem-side articulation.\n  //\n  // This indicates that all objects should have their stave set before being\n  // formatted. It can't be an optional if you want accurate vertical positioning.\n  // Consistently positioned articulations that play nice with other modifiers\n  // won't be possible until we stop relying on render-time formatting.\n  //\n  // Ideally, when this function has completed, the vertical articulation positions\n  // should be ready to render without further adjustment. But the current state\n  // is far from this ideal.\n  static format(articulations, state) {\n    if (!articulations || articulations.length === 0) return false;\n\n    const isAbove = artic => artic.getPosition() === ABOVE;\n    const isBelow = artic => artic.getPosition() === BELOW;\n    const margin = 0.5;\n    const getIncrement = (articulation, line, position) =>\n      roundToNearestHalf(\n        getRoundingFunction(line, position),\n        (articulation.glyph.getMetrics().height / 10) + margin\n      );\n\n    articulations\n      .filter(isAbove)\n      .forEach(articulation => {\n        articulation.setTextLine(state.top_text_line);\n        state.top_text_line += getIncrement(articulation, state.top_text_line, ABOVE);\n      });\n\n    articulations\n      .filter(isBelow)\n      .forEach(articulation => {\n        articulation.setTextLine(state.text_line);\n        state.text_line += getIncrement(articulation, state.text_line, BELOW);\n      });\n\n    const width = articulations\n      .map(articulation => articulation.getWidth())\n      .reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  }\n\n  static easyScoreHook({ articulations }, note, builder) {\n    if (!articulations) return;\n\n    const articNameToCode = {\n      staccato: 'a.',\n      tenuto: 'a-',\n    };\n\n    articulations\n      .split(',')\n      .map(articString => articString.trim().split('.'))\n      .map(([name, position]) => {\n        const artic = { type: articNameToCode[name] };\n        if (position) artic.position = Modifier.PositionString[position];\n        return builder.getFactory().Articulation(artic);\n      })\n      .map(artic => note.addModifier(0, artic));\n  }\n\n  // Create a new articulation of type `type`, which is an entry in\n  // `Vex.Flow.articulationCodes` in `tables.js`.\n  constructor(type) {\n    super();\n    this.setAttribute('type', 'Articulation');\n\n    this.note = null;\n    this.index = null;\n    this.type = type;\n    this.position = BELOW;\n    this.render_options = {\n      font_scale: 38,\n    };\n\n    this.reset();\n  }\n\n  reset() {\n    this.articulation = Flow.articulationCodes(this.type);\n    if (!this.articulation) {\n      throw new Vex.RERR('ArgumentError', `Articulation not found: ${this.type}`);\n    }\n\n    const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n    this.glyph = new Glyph(code, this.render_options.font_scale);\n\n    this.setWidth(this.glyph.getMetrics().width);\n  }\n\n  getCategory() { return Articulation.CATEGORY; }\n\n  // Render articulation in position next to note.\n  draw() {\n    const {\n      note, index, position, glyph,\n      articulation: { between_lines: canSitBetweenLines },\n      text_line: textLine,\n      context: ctx,\n    } = this;\n\n    this.checkContext();\n\n    if (!note || index == null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw Articulation without a note and index.\");\n    }\n\n    this.setRendered();\n\n    const stave = note.getStave();\n    const staffSpace = stave.getSpacingBetweenLines();\n    const isTab = note.getCategory() === 'tabnotes';\n\n    // Articulations are centered over/under the note head.\n    const { x } = note.getModifierStartXY(position, index);\n    const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n\n    const initialOffset = getInitialOffset(note, position);\n\n    const padding = this.musicFont.lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n\n    let y = {\n      [ABOVE]: () => {\n        glyph.setOrigin(0.5, 1);\n        const y = getTopY(note, textLine) - ((textLine + initialOffset) * staffSpace);\n        return shouldSitOutsideStaff\n          ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y)\n          : y;\n      },\n      [BELOW]: () => {\n        glyph.setOrigin(0.5, 0);\n        const y = getBottomY(note, textLine) + ((textLine + initialOffset) * staffSpace);\n        return shouldSitOutsideStaff\n          ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y)\n          : y;\n      },\n    }[position]();\n\n    if (!isTab) {\n      const offsetDirection = position === ABOVE ? -1 : +1;\n      const noteLine = isTab ? note.positions[index].str : note.getKeyProps()[index].line;\n      const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n      const articLine = distanceFromNote + noteLine;\n      const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n\n      if (isWithinLines(snappedLine, position)) glyph.setOrigin(0.5, 0.5);\n\n      y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + (padding * offsetDirection);\n    }\n\n    L(`Rendering articulation at (x: ${x}, y: ${y})`);\n\n    glyph.render(ctx, x, y);\n  }\n}\n"],"file":"articulation.js"}