{"version":3,"sources":["../../../node_modules/vexflow/src/ornament.js"],"names":["L","args","Ornament","DEBUG","Vex","Modifier","CATEGORY","format","ornaments","state","length","width","i","ornament","increment","Math","max","getWidth","getPosition","Position","ABOVE","setTextLine","top_text_line","text_line","left_shift","right_shift","constructor","type","setAttribute","note","index","position","delayed","accidentalUpper","accidentalLower","render_options","font_scale","accidentalLowerPadding","accidentalUpperPadding","Flow","ornamentCodes","RERR","glyph","Glyph","code","category","setOrigin","getCategory","setDelayed","setUpperAccidental","accid","scale","accidentalCodes","setLowerAccidental","draw","checkContext","setRendered","ctx","context","stemDir","getStemDirection","stave","getStave","stemExtents","getStem","getExtents","y","StaveNote","STEM_DOWN","baseY","topY","hasStem","getYForTopText","isPlacedOnNoteheadSide","spacing","getSpacingBetweenLines","lineSpacing","beam","totalSpacing","glyphYBetweenLines","start","getModifierStartXY","glyphX","x","glyphY","min","y_shift","delayXShift","undefined","getMetrics","nextContext","TickContext","getNextContext","getTickContext","getX","render","height"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Cyril Silverman\n//\n// ## Description\n//\n// This file implements ornaments as modifiers that can be\n// attached to notes. The complete list of ornaments is available in\n// `tables.js` under `Vex.Flow.ornamentCodes`.\n//\n// See `tests/ornament_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { TickContext } from './tickcontext';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph';\n\n// To enable logging for this class. Set `Vex.Flow.Ornament.DEBUG` to `true`.\nfunction L(...args) { if (Ornament.DEBUG) Vex.L('Vex.Flow.Ornament', args); }\n\nexport class Ornament extends Modifier {\n  static get CATEGORY() { return 'ornaments'; }\n\n  // ## Static Methods\n  // Arrange ornaments inside `ModifierContext`\n  static format(ornaments, state) {\n    if (!ornaments || ornaments.length === 0) return false;\n\n    let width = 0;\n    for (let i = 0; i < ornaments.length; ++i) {\n      const ornament = ornaments[i];\n      const increment = 2;\n\n      width = Math.max(ornament.getWidth(), width);\n\n      if (ornament.getPosition() === Modifier.Position.ABOVE) {\n        ornament.setTextLine(state.top_text_line);\n        state.top_text_line += increment;\n      } else {\n        ornament.setTextLine(state.text_line);\n        state.text_line += increment;\n      }\n    }\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  }\n\n  // Create a new ornament of type `type`, which is an entry in\n  // `Vex.Flow.ornamentCodes` in `tables.js`.\n  constructor(type) {\n    super();\n    this.setAttribute('type', 'Ornament');\n\n    this.note = null;\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.ABOVE;\n    this.delayed = false;\n\n    this.accidentalUpper = null;\n    this.accidentalLower = null;\n\n    this.render_options = {\n      font_scale: 38,\n      accidentalLowerPadding: 3,\n      accidentalUpperPadding: 3,\n    };\n\n    this.ornament = Flow.ornamentCodes(this.type);\n    if (!this.ornament) {\n      throw new Vex.RERR('ArgumentError', `Ornament not found: '${this.type}'`);\n    }\n\n    this.glyph = new Glyph(this.ornament.code, this.render_options.font_scale, { category: `ornament.${this.ornament.code}` });\n    this.glyph.setOrigin(0.5, 1.0); // FIXME: SMuFL won't require a vertical origin shift\n  }\n\n  getCategory() { return Ornament.CATEGORY; }\n\n  // Set whether the ornament is to be delayed\n  setDelayed(delayed) { this.delayed = delayed; return this; }\n\n  // Set the upper accidental for the ornament\n  setUpperAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalUpper = new Glyph(Flow.accidentalCodes(accid).code, scale);\n    this.accidentalUpper.setOrigin(0.5, 1.0);\n    return this;\n  }\n\n  // Set the lower accidental for the ornament\n  setLowerAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalLower = new Glyph(Flow.accidentalCodes(accid).code, scale);\n    this.accidentalLower.setOrigin(0.5, 1.0);\n    return this;\n  }\n\n  // Render ornament in position next to note.\n  draw() {\n    this.checkContext();\n\n    if (!this.note || this.index == null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw Ornament without a note and index.\");\n    }\n\n    this.setRendered();\n\n    const ctx = this.context;\n    const stemDir = this.note.getStemDirection();\n    const stave = this.note.getStave();\n\n    // Get stem extents\n    const stemExtents = this.note.getStem().getExtents();\n    let y = stemDir === StaveNote.STEM_DOWN ? stemExtents.baseY : stemExtents.topY;\n\n    // TabNotes don't have stems attached to them. Tab stems are rendered\n    // outside the stave.\n    if (this.note.getCategory() === 'tabnotes') {\n      if (this.note.hasStem()) {\n        if (stemDir === StaveNote.STEM_DOWN) {\n          y = stave.getYForTopText(this.text_line);\n        }\n      } else { // Without a stem\n        y = stave.getYForTopText(this.text_line);\n      }\n    }\n\n    const isPlacedOnNoteheadSide = stemDir === StaveNote.STEM_DOWN;\n    const spacing = stave.getSpacingBetweenLines();\n    let lineSpacing = 1;\n\n    // Beamed stems are longer than quarter note stems, adjust accordingly\n    if (!isPlacedOnNoteheadSide && this.note.beam) {\n      lineSpacing += 0.5;\n    }\n\n    const totalSpacing = spacing * (this.text_line + lineSpacing);\n    const glyphYBetweenLines = y - totalSpacing;\n\n    // Get initial coordinates for the modifier position\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let glyphX = start.x;\n    let glyphY = Math.min(stave.getYForTopText(this.text_line), glyphYBetweenLines);\n    glyphY += this.y_shift;\n\n    // Ajdust x position if ornament is delayed\n    if (this.delayed) {\n      let delayXShift = 0;\n      if (this.delayXShift !== undefined) {\n        delayXShift = this.delayXShift;\n      } else {\n        delayXShift += this.glyph.getMetrics().width / 2;\n        const nextContext = TickContext.getNextContext(this.note.getTickContext());\n        if (nextContext) {\n          delayXShift += (nextContext.getX() - glyphX) * 0.5;\n        } else {\n          delayXShift += (stave.x + stave.width - glyphX) * 0.5;\n        }\n        this.delayXShift = delayXShift;\n      }\n      glyphX += delayXShift;\n    }\n\n    L('Rendering ornament: ', this.ornament, glyphX, glyphY);\n\n    if (this.accidentalLower) {\n      this.accidentalLower.render(ctx, glyphX, glyphY);\n      glyphY -= this.accidentalLower.getMetrics().height;\n      glyphY -= this.render_options.accidentalLowerPadding;\n    }\n\n    this.glyph.render(ctx, glyphX, glyphY);\n    glyphY -= this.glyph.getMetrics().height;\n\n    if (this.accidentalUpper) {\n      glyphY -= this.render_options.accidentalUpperPadding;\n      this.accidentalUpper.render(ctx, glyphX, glyphY);\n    }\n  }\n}\n"],"file":"ornament.js"}